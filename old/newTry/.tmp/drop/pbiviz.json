{"visual":{"name":"Time series decomposition","displayName":"Time series decomposition","guid":"PBI_CV_Template","visualClassName":"Visual","version":"1.0.0","description":"<span>Some description <br/><br/><span style='font-style:italic'>Service prerequisites:</span> R-powered custom visual is used in service seamlessly<br/><br /><span style='font-style:italic'>Desktop prerequisites:</span> To run R scripts in Power BI Desktop, you must separately install R on your local computer.<br />You can download and install R for free from the <a href='https://mran.revolutionanalytics.com/download/'>Revolution Open download page</a> or the <a href='https://cran.r-project.org/bin/windows/base/'>CRAN Repository</a><br /><br /> <span style='font-style:italic'> R package dependencies(auto-installed): </span> some packages <br /><br /> <span style='font-style:italic'> Supports R versions: </span> R 3.3.1, R 3.3.0, MRO 3.3.1, MRO 3.3.0 <br /></span>","supportUrl":"http://community.powerbi.com/","gitHubUrl":""},"apiVersion":"1.3.0","author":{"name":"","email":""},"assets":{"icon":"assets/icon.png"},"externalJS":[],"style":"style/visual.less","capabilities":{"dataRoles":[{"displayName":"Time","description":"Time column","kind":"Grouping","name":"Time"},{"displayName":"Value","description":"Numeric","kind":"Measure","name":"Value"}],"dataViewMappings":[{"conditions":[{"Time":{"max":1},"Value":{"max":1}}],"scriptResult":{"dataInput":{"table":{"rows":{"select":[{"for":{"in":"Time"}},{"for":{"in":"Value"}}],"dataReductionAlgorithm":{"top":{}}}}},"script":{"scriptProviderDefault":"R","scriptOutputType":"png","source":{"objectName":"rcv_script","propertyName":"source"},"provider":{"objectName":"rcv_script","propertyName":"provider"},"scriptSourceDefault":"#----------------------------------\r\n#toydata\r\nset.seed(42)\r\nmy.dates = seq(as.Date(\"1999/1/1\"), as.Date(\"2012/1/1\"), \"3 months\") \r\nTime = format(my.dates, format = \"%Y-%m-%dT%H:%M:%S\",tz=\"UTC\")\r\nnames(Time)[1] = \"myTime\"\r\nValue = data.frame( v = seq(1,length(Time))/10 + rep(c(1,2,3,4), length.out = length(Time)) + runif(length(Time), min=0, max=3))\r\n\r\n\r\n###############Library Declarations###############\r\n\r\nlibraryRequireInstall = function(packageName, ...)\r\n{\r\n  if(!require(packageName, character.only = TRUE)) \r\n    warning(paste(\"*** The package: '\", packageName, \"' was not installed ***\",sep=\"\"))\r\n}\r\n\r\nlibraryRequireInstall(\"zoo\")\r\nlibraryRequireInstall(\"proto\")\r\n\r\n\r\n\r\n#################################################\r\n\r\n\r\nminSeasonalityEnergyFactor = 0.5 # if seasonality should reduce reminder by 50% at least \r\n\r\n\r\n# tiny function to deal with verl long strings on plot\r\ncutStr2Show = function(strText, strCex = 0.8, abbrTo = 100, isH = TRUE, maxChar = 3, partAvailable = 1)\r\n{\r\n  # partAvailable, wich portion of window is available, in [0,1]\r\n  if(is.null(strText))\r\n    return (NULL)\r\n  \r\n  SCL = 0.075*strCex/0.8\r\n  pardin = par()$din\r\n  gStand = partAvailable*(isH*pardin[1]+(1-isH)*pardin[2]) /SCL\r\n  \r\n  # if very very long abbreviate\r\n  if(nchar(strText)>abbrTo && nchar(strText)> 1)\r\n    strText = abbreviate(strText, abbrTo)\r\n  \r\n  # if looooooong convert to lo...\r\n  if(nchar(strText)>round(gStand) && nchar(strText)> 1)\r\n    strText = paste(substring(strText,1,floor(gStand)),\"...\",sep=\"\")\r\n  \r\n  # if shorter than maxChar remove \r\n  if(gStand<=maxChar)\r\n    strText = NULL\r\n  \r\n  return(strText) \r\n}\r\n\r\n#format labels on X-axis automatically \r\nflexFormat = function(dates, orig_dates, freq = 1, myformat = NULL)\r\n{\r\n  \r\n  days=(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  months = days/30\r\n  years = days/365.25\r\n  \r\n  \r\n  constHour = length(unique(orig_dates$hour))==1\r\n  constMin = length(unique(orig_dates$min))==1\r\n  constSec = length(unique(orig_dates$sec))==1\r\n  constMon = length(unique(orig_dates$mon))==1\r\n  \r\n  timeChange = any(!constHour,!constMin,!constSec)\r\n  \r\n  if(is.null(myformat))\r\n  {\r\n    if(years > 10){\r\n      if(constMon)\r\n      {\r\n        myformat = \"%Y\" #many years => only year :2001\r\n      }else{\r\n        myformat = \"%m/%y\" #many years + months :12/01\r\n      }\r\n    }else{\r\n      if(years > 1 && N < 50){\r\n        myformat = \"%b %d, %Y\" #several years, few samples:Jan 01, 2010\r\n      }else{\r\n        if(years > 1){\r\n          myformat = \"%m/%d/%y\" #several years, many samples: 01/20/10\r\n        }else{\r\n          if(years <= 1 && !timeChange)\r\n            myformat = \"%b %d\" #1 year,no time: Jan 01\r\n        }  \r\n      }\r\n    }\r\n  }\r\n  if(is.null(myformat) && timeChange)\r\n    if(years>1){\r\n      myformat = \"%m/%d/%y %H:%M\" # 01/20/10 12:00\r\n    }else{\r\n      if(days>1){\r\n        myformat = \"%b %d, %H:%M\" # Jan 01 12:00\r\n      }else{\r\n        if(days<=1){\r\n          myformat = \"%H:%M\" # Jan 01 12:00\r\n        }  \r\n      }\r\n    }\r\n  if(!is.null(myformat)){\r\n    if(myformat == \"%Y,Q%q\")\r\n      dates = as.yearqtr(dates)\r\n    dates1= format(dates,  myformat)\r\n  }else{\r\n    dates1 = as.character(1:length(dates)) # just id \r\n  }\r\n  return(dates1)\r\n}\r\n\r\n\r\n\r\n# from : http://stats.stackexchange.com/questions/1207/period-detection-of-a-generic-time-series\r\nfreqFromValue <- function(x)\r\n{\r\n  n <- length(x)\r\n  spec <- spec.ar(c(x),plot=FALSE)\r\n  if(max(spec$spec)>10) # Arbitrary threshold chosen by trial and error.\r\n  {\r\n    period <- round(1/spec$freq[which.max(spec$spec)])\r\n    if(period==Inf) # Find next local maximum\r\n    {\r\n      j <- which(diff(spec$spec)>0)\r\n      if(length(j)>0)\r\n      {\r\n        nextmax <- j[1] + which.max(spec$spec[j[1]:500])\r\n        period <- round(1/spec$freq[nextmax])\r\n      }\r\n      else\r\n        period <- 1\r\n    }\r\n  }\r\n  else\r\n    period <- 1\r\n  return(period)\r\n}\r\n\r\n\r\n# verify if \"perSeason\" is good for \"frequency\" parameter\r\nfreqSeason = function(seasons,perSeason)\r\n{\r\n  if((seasons > 5 && perSeason > 3) || (seasons>2 && perSeason > 7))\r\n    return (perSeason)\r\n  \r\n  return(1)\r\n}\r\n\r\n# find frequency using the dates, targetS is a \"recommended\" seasonality \r\nfindFreqFromDates = function(dates, targetS = \"autodetect from dates\")\r\n{\r\n  freq = 1\r\n  N = length(dates)\r\n  nnn = c(\"hour\", \"day\", \"week\", \"month\", \"quater\", \"year\")\r\n  seasons = rep(NaN,6)\r\n  names(seasons) = nnn\r\n  perSeason = seasons\r\n  \r\n  seasons[\"day\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"days\"))\r\n  seasons[\"hour\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"hours\"))\r\n  seasons[\"week\"]=round(as.numeric(difftime(dates[length(dates)],dates[1]),units=\"weeks\"))\r\n  seasons[\"month\"] = seasons[\"day\"]/30\r\n  seasons[\"year\"] = seasons[\"day\"]/365.25\r\n  seasons[\"quater\"] = seasons[\"year\"]*4\r\n  \r\n  perSeason = N/seasons\r\n  \r\n  if(targetS!=\"autodetect from date\") # target \r\n    freq = perSeason[targetS]\r\n  \r\n  if(freq < 2 || round(freq)>24) # if TRUE, target season factor is not good \r\n    freq = 1\r\n  \r\n  for( s in rev(nnn)) # check year --> Quater --> etc\r\n    if(freq==1 || round(freq)>24)\r\n      freq = freqSeason(seasons[s],perSeason[s])\r\n  \r\n  \r\n  if(round(freq)>24) # limit of exp smoothing R implementation\r\n    freq = 1\r\n  \r\n  return(round(freq))\r\n}\r\n\r\n\r\n\r\n#decompose into 3 components, known frequency \r\nflexTSdecomposition = function(Time, Value, freq, trendSmoothness, myts, robustToOutliers, degree)\r\n{\r\n  N = length(Time)\r\n  twin = getSTwindows(N, trendSmoothness= trendSmoothness, freq = freq)\r\n  \r\n  if(freq ==1)\r\n  {\r\n    s = (100*trendSmoothness/70)\r\n    span = max(s,0.2) # get from t smoothness\r\n    #fit <- loess(Value[,1] ~ Time, degree = 1+ degree, span = span)\r\n    fit <- loess(Value[,1] ~ seq(1,length(Time)), degree = 1+ degree, span = span)\r\n    fit$time.series.df = data.frame(seasonal = rep(0, length(Time)), trend = fit$fitted, residuals = fit$residuals, data = Value[,1])\r\n    \r\n  } \r\n  if(freq >1)\r\n  {\r\n    ## Convert to time series\r\n    fit <- stl(myts,  robust = robustToOutliers, s.degree = degree, s.window = \"periodic\", t.window = twin)\r\n    fit$time.series.df = as.data.frame(fit$time.series)\r\n    fit$fitted = fit$time.series.df$seasonal+ fit$time.series.df$trend\r\n    fit$residuals = Value[,1] - fit$fitted\r\n    \r\n  }\r\n  \r\n  \r\n  clean = fit$time.series.df[,1]+fit$time.series.df[,2]\r\n  seasonal = fit$time.series.df[,1]+mean(fit$time.series.df[,2])\r\n  reminder = fit$time.series.df[,3]+mean(Value[,1])\r\n  trend = fit$time.series.df[,2]\r\n  \r\n  dfTSD = data.frame(clean= clean, seasonal = seasonal, trend = trend, reminder = reminder)\r\n  \r\n  \r\n  \r\n}\r\n\r\n#find relative part of signal\r\nexplained = function(sigModeled, sig)\r\n{\r\n  normL2sig = norm(sig, type =\"2\")\r\n  normL2err = norm(sig - sigModeled, type =\"2\")\r\n  return(1-(normL2err/(normL2sig+0.00001)))\r\n}\r\n\r\nnextodd = function(num)\r\n{\r\n  return (round(num)+(round(num) %% 2 == 0))\r\n}\r\n\r\ngetByPos = function(arr,frac)\r\n  arr[max(1,round(length(arr)*frac))]\r\n\r\n\r\ngetSTwindows = function(numSamples, trendSmoothness= 0.5, freq = 4)\r\n{\r\n  t = nextodd(freq*1.5)# default\r\n  \r\n  allTS = seq(3,max(7,max(t*2, nextodd(numSamples/2))), by = 2)\r\n  \r\n  return(getByPos(allTS,trendSmoothness))\r\n}\r\n\r\ngetFrequency = function(parsed_dates,val,tS,f)\r\n{\r\n  \r\n  myFreq = f\r\n  grp = c(\"autodetect from value\",\"none\",\"manual\")\r\n  \r\n  if(length(intersect(tS,grp))==0) #detect from date\r\n  {  \r\n    myFreq = findFreqFromDates(parsed_dates, targetS = tS)\r\n  }else{\r\n    if(tS == \"none\")\r\n    { myFreq = 1}\r\n    else\r\n    {\r\n    if(tS == \"autodetect from value\")\r\n      myFreq = freqFromValue(val)\r\n    }\r\n  }\r\n  numPeriods = floor(length(val)/myFreq)\r\n  if(numPeriods< 2)\r\n    myFreq = findFreqFromDates(parsed_dates, targetS = \"autodetect from dates\")\r\n  return(myFreq)\r\n}\r\n\r\n\r\n#plotType: clean, trend, seasonal, all, reminder\r\n\r\n#********* PBI Parameters Block ***************\r\nif(!exists(\"Time\"))\r\n\tTime = NULL \r\n\r\nif(!exists(\"Value\"))\r\n\tValue = NULL \r\n\r\nshowWarnInfo = TRUE  #default\r\nif (exists(\"settings_extra_params_show\")) \r\n{\r\n\tshowWarnInfo = settings_extra_params_show\r\n}\r\n\r\nif(exists(\"settings_model_params_show\") && settings_model_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_model_params_\" ))\r\n\r\nif(exists(\"settings_algo_params_show\") && settings_algo_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_algo_params_\" ))\r\n\r\nif(exists(\"settings_plot_params_show\") && settings_plot_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_plot_params_\" ))\r\n\r\nif(exists(\"settings_extra_params_show\") && settings_extra_params_show == FALSE)\r\n\trm(list= ls(pattern = \"settings_extra_params_\" ))\r\n\r\n##PBI_PARAM: display_name: Decomposition model, tooltip:switch between additive and multiplicative decomposition models \r\n# Type: enumeration, default:'automatic', \r\n# Min: , Max:\r\n# enumeration options: additive ,multiplicative ,automatic ,\r\nmodelType = 'automatic'  #default\r\nif (exists(\"settings_model_params_modelType\")) \r\n{\r\n\tmodelType = settings_model_params_modelType\r\n}\r\n\r\n##PBI_PARAM: display_name: Seasonal factor, tooltip:specify target seasonal factor\r\n# Type: enumeration, default:'auto-detect from dates', \r\n# Min: , Max:\r\n# enumeration options: autodetect from value ,autodetect from date ,none ,manual ,hour ,day ,week ,month ,quater ,year ,\r\ntargetSeasonality = 'auto-detect from dates'  #default\r\nif (exists(\"settings_model_params_targetSeasonality\")) \r\n{\r\n\ttargetSeasonality = settings_model_params_targetSeasonality\r\n}\r\n\r\n##PBI_PARAM: display_name: Frequency, tooltip:Number of samples per period\r\n# Type: numeric, default:12, \r\n# Min: 1, Max:10000\r\nfreq = 12  #default\r\nif (exists(\"settings_model_params_freq\")) \r\n{\r\n\tfreq = settings_model_params_freq\r\n\tfreq = max( min (freq, 10000), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Degree, tooltip:degree of locally-fitted polynomial in seasonal extraction and trend extraction\r\n# Type: bool, default:FALSE, \r\n# Min: , Max:\r\ndegree = FALSE  #default\r\nif (exists(\"settings_algo_params_degree\")) \r\n{\r\n\tdegree = settings_algo_params_degree\r\n}\r\n\r\n##PBI_PARAM: display_name: Robust to outliers, tooltip:logical indicating if robust fitting be used in the loess procedure\r\n# Type: bool, default:TRUE, \r\n# Min: , Max:\r\nrobustToOutliers = TRUE  #default\r\nif (exists(\"settings_algo_params_robustToOutliers\")) \r\n{\r\n\trobustToOutliers = settings_algo_params_robustToOutliers\r\n}\r\n\r\n##PBI_PARAM: display_name: Trend smoothness, tooltip:Trend smoothness\r\n# Type: numeric, default:50, \r\n# Min: 1, Max:100\r\ntrendSmoothness = 50  #default\r\nif (exists(\"settings_algo_params_percentile\")) \r\n{\r\n\ttrendSmoothness = settings_algo_params_percentile\r\n\ttrendSmoothness = max( min (trendSmoothness, 100), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Plot type, tooltip:specify the plot type\r\n# Type: enumeration, default:'all', \r\n# Min: , Max:\r\n# enumeration options: all ,trend ,seasonal ,clean ,reminder ,byseason ,\r\nplotType = 'all'  #default\r\nif (exists(\"settings_plot_params_plotType\")) \r\n{\r\n\tplotType = settings_plot_params_plotType\r\n}\r\n\r\n##PBI_PARAM: display_name: Line width, tooltip:line width\r\n# Type: numeric, default:10, \r\n# Min: 1, Max:50\r\nlineWidth = 10  #default\r\nif (exists(\"settings_plot_params_weight\")) \r\n{\r\n\tlineWidth = settings_plot_params_weight\r\n\tlineWidth = max( min (lineWidth, 50), 1)\r\n}\r\n\r\n##PBI_PARAM: display_name: Line color, tooltip:line color\r\n# Type: fill, default:'red', \r\n# Min: , Max:\r\nlineCol = 'red'  #default\r\nif (exists(\"settings_plot_params_lineCol\")) \r\n{\r\n\tlineCol = settings_plot_params_lineCol\r\n}\r\n\r\n##PBI_PARAM: display_name: Labels color, tooltip:labels color\r\n# Type: fill, default:'orange', \r\n# Min: , Max:\r\nlabelsCol = 'orange'  #default\r\nif (exists(\"settings_plot_params_labelsCol\")) \r\n{\r\n\tlabelsCol = settings_plot_params_labelsCol\r\n}\r\n\r\n##PBI_PARAM: display_name: Labels font size, tooltip:labels font size\r\n# Type: numeric, default:10, \r\n# Min: 8, Max:40\r\nlabelsFont = 10  #default\r\nif (exists(\"settings_plot_params_textSize\")) \r\n{\r\n\tlabelsFont = settings_plot_params_textSize\r\n\tlabelsFont = max( min (labelsFont, 40), 8)\r\n}\r\n\r\n##PBI_PARAM: display_name: Font size, tooltip:\r\n# Type: numeric, default:8, \r\n# Min: 8, Max:40\r\ninfoFontSize = 8  #default\r\nif (exists(\"settings_extra_params_textSize\")) \r\n{\r\n\tinfoFontSize = settings_extra_params_textSize\r\n\tinfoFontSize = max( min (infoFontSize, 40), 8)\r\n}\r\n\r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n \r\n{\r\n  #update params to correct scale\r\n  trendSmoothness = trendSmoothness/100\r\n  labelsFont = labelsFont/10 # convert from range 8-40\r\n  lineWidth = lineWidth / 8 # convert from 1-50 \r\n  infoFontSize = infoFontSize/10\r\n  \r\n  \r\n  N = length(Time)\r\n  \r\n  parsed_dates=strptime(Time,\"%Y-%m-%dT%H:%M:%S\",tz=\"UTC\")\r\n  interval = difftime(parsed_dates[length(parsed_dates)],parsed_dates[1])/(length(parsed_dates)-1) # force equal spacing \r\n  x = as.POSIXlt(seq(from=parsed_dates[1], by= interval, length.out=length(parsed_dates)))\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  #to be able to change lwd \r\n  mypanel= function(x, bg, pch, ...){ lines(x, bg, pch, col.lab = labelsCol, ...)}\r\n  \r\n  \r\n  #detect the frequency \r\n  freq = getFrequency(parsed_dates,Value[,1],targetSeasonality,freq)\r\n  print(freq)\r\n  \r\n  # Convert to time series\r\n  myts <- ts(Value[,1], start = as.Date(min(Time)), frequency = freq)\r\n  \r\n  \r\n  # decompose\r\n  dfTSD <- flexTSdecomposition(Time, Value, freq, trendSmoothness, myts, robustToOutliers, degree)\r\n  \r\n  \r\n  #plots \r\n  if (plotType == \"byseason\" && freq == 1)\r\n    plotType = \"all\"\r\n  \r\n  \r\n  #format  x_with_f\r\n # numTicks = FindTicksNum(NpF,freq) # find based on plot size\r\n  \r\n  # x_formatted = flexFormat(dates = x, orig_dates = parsed_dates, freq = freq)\r\n  # \r\n  # numTicks = 5\r\n  # correction = (N-1)/(numTicks-1) # needed due to subsampling of ticks\r\n  # \r\n  \r\n  myts_zoo = as.zoo(myts)\r\n  time(myts_zoo) = parsed_dates\r\n  \r\n  \r\n  ## Plot the result\r\n  if(plotType == \"all\" )\r\n  {\r\n    \r\n    mts0 = cbind(data=Value[,1], seasonal = dfTSD$seasonal  , trend=dfTSD$trend, remainder=dfTSD$reminder)\r\n    mts1 = ts(mts0, start = as.Date(min(Time)), frequency= freq)\r\n    \r\n    mts1_zoo = as.zoo(mts1)\r\n    time(mts1_zoo) = parsed_dates\r\n    \r\n   \r\n    p <- proto(plot.zoo = plot.zoo, mtext = function(...) \r\n      graphics::mtext(..., cex = labelsFont, col = labelsCol))\r\n    \r\n    with(p, plot.zoo)(mts1_zoo, main=\"\", col = lineCol, plot.type = c(\"multiple\"),\r\n         yax.flip = TRUE,\r\n         col.lab = labelsCol,  panel = mypanel, lwd =lineWidth,  cex.lab = labelsFont)\r\n   \r\n    \r\n  # (mts1_zoo) \r\n    \r\n    \r\n  }\r\n  else\r\n    if(plotType != \"byseason\")\r\n    {\r\n      \r\n      plot(myts_zoo, col=\"gray\",\r\n           main=\"\",\r\n           lwd = lineWidth/2,  col.lab = labelsCol, cex.lab = labelsFont, xlab = \"\", ylab = \"\")\r\n      \r\n      dfTSD <- ts(dfTSD, start = as.Date(min(Time)), frequency= freq)\r\n     \r\n      line_zoo = as.zoo(dfTSD[,plotType])\r\n      time(line_zoo) = parsed_dates\r\n      \r\n      # lines(dfTSD[,plotType], col = lineCol, lwd = lineWidth)\r\n      lines(line_zoo, col = lineCol, lwd = lineWidth)\r\n      \r\n      abline(a = mean(Value[,1]), b = 0, col = \"green\", lty = 2, col.lab = labelsCol)\r\n      \r\n      title(main=\"\", \r\n            xlab=names(Time)[1], ylab=names(Value)[1],\r\n            col.lab=labelsCol, cex.lab=labelsFont)\r\n      #axis(1, at = 1+((0:(53-1))/freq), labels = x_formatted)\r\n      #TODO: legend\r\n      #legend(\"topleft\", c(\"data\",plotType,\"mean\"), lty=c(1,1,2), pch = NA,  col = c(\"gray\",lineCol,\"green\"))\r\n    } else {\r\n      if(plotType == \"byseason\")\r\n      {\r\n        fit <- stl(myts, s.window=5)\r\n        par(lwd = lineWidth, col = lineCol)\r\n        monthplot(fit$time.series[,\"seasonal\"], main=\"\", ylab=\"Seasonal\", \r\n                  col.lab=labelsCol, cex.lab=labelsFont, col.base = \"gray\", lwd.base = lineWidth/2, bty='n')\r\n        box(col = 'black', lwd =1)\r\n      }\r\n    }\r\n  \r\n}\r\n\r\n#########################\r\n# \r\n# TimeSeriesDecomposition(Time,Value,\r\n#                         targetSeasonality = \"month\", # one of \"autodetect from date\", \"autodetect from value\", none, manual, year, month, ...\r\n#                         freq = 4, # for manual seasonality\r\n#                         modelType = \"additive\", # additive/multiplicative/automatic\r\n#                         trendSmoothness = 50,# in 0-100\r\n#                         degree = 1,\r\n#                         robustToOutliers = TRUE,\r\n#                         plotType = \"byseason\", # all, clean, trend, seasonal, reminder, byseason\r\n#                         lineWidth = 20, #\r\n#                         lineCol = \"red\",\r\n#                         labelsCol = \"orange\",\r\n#                         labelsFont = 5,\r\n#                         infoFontSize = 8,\r\n#                         showInfoWarn = TRUE)\r\n"}}}],"objects":{"settings_model_params":{"displayName":"Time series decomposition","properties":{"modelType":{"displayName":"Decomposition model","description":"switch between additive and multiplicative decomposition models ","type":{"enumeration":[{"displayName":"additive","value":"additive"},{"displayName":"multiplicative","value":"multiplicative"},{"displayName":"automatic","value":"automatic"}]}},"targetSeasonality":{"displayName":"Seasonal factor","description":"specify target seasonal factor","type":{"enumeration":[{"displayName":"autodetect from value","value":"autodetect from value"},{"displayName":"autodetect from date","value":"autodetect from date"},{"displayName":"none","value":"none"},{"displayName":"manual","value":"manual"},{"displayName":"hour","value":"hour"},{"displayName":"day","value":"day"},{"displayName":"week","value":"week"},{"displayName":"month","value":"month"},{"displayName":"quater","value":"quater"},{"displayName":"year","value":"year"}]}},"freq":{"displayName":"Frequency","description":"Number of samples per period","type":{"numeric":true}}}},"settings_algo_params":{"displayName":"Algorithm parameters","description":"Control inner parameters of 'Seasonal Decomposition of Time Series by Loess'","properties":{"degree":{"displayName":"Degree","description":"degree of locally-fitted polynomial in seasonal extraction and trend extraction","type":{"bool":true}},"robustToOutliers":{"displayName":"Robust to outliers","description":"logical indicating if robust fitting be used in the loess procedure","type":{"bool":true}},"percentile":{"displayName":"Trend smoothness","description":"Trend smoothness","type":{"numeric":true}}}},"settings_plot_params":{"displayName":"Graphical parameters","description":" Select plot type and visualisation attributes","properties":{"plotType":{"displayName":"Plot type","description":"specify the plot type","type":{"enumeration":[{"displayName":"decomposition","value":"all"},{"displayName":"trend","value":"trend"},{"displayName":"seasonal","value":"seasonal"},{"displayName":"clean","value":"clean"},{"displayName":"reminder","value":"reminder"},{"displayName":"by season","value":"byseason"}]}},"weight":{"displayName":"Line width","description":"line width","type":{"numeric":true}},"lineCol":{"displayName":"Line color","description":"line color","type":{"fill":{"solid":{"color":true}}}},"labelsCol":{"displayName":"Labels color","description":"labels color","type":{"fill":{"solid":{"color":true}}}},"textSize":{"displayName":"Labels font size","description":"labels font size","type":{"numeric":true}}}},"settings_extra_params":{"displayName":"Show information","description":" Show infromation and warnings","properties":{"show":{"type":{"bool":true}},"textSize":{"displayName":"Font size","type":{"numeric":true}}}},"colorSelector":{"displayName":"Data Colors","properties":{"fill":{"displayName":"Color","type":{"fill":{"solid":{"color":true}}}}}},"rcv_script":{"properties":{"provider":{"type":{"text":true}},"source":{"type":{"scripting":{"source":true}}}}}},"suppressDefaultTitle":true},"dependencies":{"cranPackages":[{"name":"ggplot2","displayName":"ggplot2: An Implementation of the Grammar of Graphics","url":"https://cran.r-project.org/web/packages/ggplot2/index.html"},{"name":"zoo","displayName":"zoo: S3 Infrastructure for Regular and Irregular Time Series","url":"https://cran.r-project.org/web/packages/zoo/index.html"}]},"content":{"js":"var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){function t(e,t,a,i){if(e){var s=e[t];if(s){var r=s[a];if(void 0!==r)return r}}return i}function a(e,t,a,i,s,r){if(e){var n=e[t];if(n){var o=n[a];if(o<s)return s;if(o>r)return r;if(void 0!==o)return o}}return i}function i(e,t,a,i,s,r){if(e){var n=e[t];if(n){var o=n[a];if(void 0!==o)return o>r?r:o<s?s:o}}return i}function s(e,t,a,i,s,r){return r&&t==a&&1==s?i:r&&t!=a&&0==s?i:e}function r(e,t){return\"auto\"!=t?\"None\":\"auto\"==t&&\"None\"==e?\"fast\":e}function n(e,t,a){return e<t?t:e>a?a:e}function o(e,t,a,i,s){var r=e.objects;if(r){var n=r[t];if(n){var o=n[a];if(o){var l=o[i];if(void 0!==l)return l}}}return s}function l(e,t,a,i){if(e){var s=e[t];if(s){var r=s[a];if(void 0!==r&&void 0!==r.solid&&void 0!==r.solid.color)return r.solid.color}}return i}e.getValue=t,e.getValueMinMax=a,e.getValueNumberMinMax=i,e.ifStringReturnString=s,e.ifStringReturnStringClustersMethod=r,e.inMinMax=n,e.getCategoricalObjectValue=o,e.getFillValue=l}(t=e.PBI_CV_Template||(e.PBI_CV_Template={}))}(t=e.visual||(e.visual={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(e){var t;!function(e){var t;!function(e){var t=function(){function t(e){this.imageDiv=document.createElement(\"div\"),this.imageDiv.className=\"rcv_autoScaleImageContainer\",e.element.appendChild(this.imageDiv),this.imageElement=document.createElement(\"img\"),this.imageElement.className=\"rcv_autoScaleImage\",this.imageDiv.appendChild(this.imageElement),this.settings_model_params={modelType:\"automatic\",targetSeasonality:\"auto-detect from dates\",freq:12},this.settings_algo_params={degree:!1,robustToOutliers:!0,percentile:50},this.settings_plot_params={plotType:\"all\",weight:10,lineCol:\"red\",labelsCol:\"orange\",textSize:10},this.settings_extra_params={show:!0,textSize:8}}return t.prototype.update=function(t){var a=t.dataViews;if(a&&0!==a.length){var i=a[0];if(i&&i.metadata){this.settings_model_params={modelType:e.getValue(i.metadata.objects,\"settings_model_params\",\"modelType\",\"automatic\"),targetSeasonality:e.getValue(i.metadata.objects,\"settings_model_params\",\"targetSeasonality\",\"auto-detect from dates\"),freq:e.getValue(i.metadata.objects,\"settings_model_params\",\"freq\",12)},this.settings_algo_params={degree:e.getValue(i.metadata.objects,\"settings_algo_params\",\"degree\",!1),robustToOutliers:e.getValue(i.metadata.objects,\"settings_algo_params\",\"robustToOutliers\",!0),percentile:e.getValue(i.metadata.objects,\"settings_algo_params\",\"percentile\",50)},this.settings_plot_params={plotType:e.getValue(i.metadata.objects,\"settings_plot_params\",\"plotType\",\"all\"),weight:e.getValue(i.metadata.objects,\"settings_plot_params\",\"weight\",10),lineCol:e.getValue(i.metadata.objects,\"settings_plot_params\",\"lineCol\",\"red\"),labelsCol:e.getValue(i.metadata.objects,\"settings_plot_params\",\"labelsCol\",\"orange\"),textSize:e.getValue(i.metadata.objects,\"settings_plot_params\",\"textSize\",10)},this.settings_extra_params={show:e.getValue(i.metadata.objects,\"settings_extra_params\",\"show\",!0),textSize:e.getValue(i.metadata.objects,\"settings_extra_params\",\"textSize\",8)};var s=null;i.scriptResult&&i.scriptResult.payloadBase64&&(s=\"data:image/png;base64,\"+i.scriptResult.payloadBase64),s?this.imageElement.src=s:this.imageElement.src=null,this.onResizing(t.viewport)}}},t.prototype.onResizing=function(e){this.imageDiv.style.height=e.height+\"px\",this.imageDiv.style.width=e.width+\"px\"},t.prototype.enumerateObjectInstances=function(t){var a=t.objectName,i=[];switch(a){case\"settings_model_params\":i.push({objectName:a,properties:{modelType:this.settings_model_params.modelType,targetSeasonality:this.settings_model_params.targetSeasonality,freq:e.inMinMax(this.settings_model_params.freq,1,1e4)},selector:null});break;case\"settings_algo_params\":i.push({objectName:a,properties:{degree:this.settings_algo_params.degree,robustToOutliers:this.settings_algo_params.robustToOutliers,percentile:e.inMinMax(this.settings_algo_params.percentile,1,100)},selector:null});break;case\"settings_plot_params\":i.push({objectName:a,properties:{plotType:this.settings_plot_params.plotType,weight:e.inMinMax(this.settings_plot_params.weight,1,50),lineCol:this.settings_plot_params.lineCol,labelsCol:this.settings_plot_params.labelsCol,textSize:e.inMinMax(this.settings_plot_params.textSize,8,40)},selector:null});break;case\"settings_extra_params\":i.push({objectName:a,properties:{show:this.settings_extra_params.show,textSize:e.inMinMax(this.settings_extra_params.textSize,8,40)},selector:null})}return i},t}();e.Visual=t}(t=e.PBI_CV_Template||(e.PBI_CV_Template={}))}(t=e.visual||(e.visual={}))}(t=e.extensibility||(e.extensibility={}))}(powerbi||(powerbi={}));var powerbi;!function(e){var t;!function(t){var a;!function(t){t.PBI_CV_Template={name:\"PBI_CV_Template\",displayName:\"Time series decomposition\",class:\"Visual\",version:\"1.0.0\",apiVersion:\"1.3.0\",create:function(t){return new e.extensibility.visual.PBI_CV_Template.Visual(t)},custom:!0}}(a=t.plugins||(t.plugins={}))}(t=e.visuals||(e.visuals={}))}(powerbi||(powerbi={}));","css":".visual-PBI_CV_Template .rcv_autoScaleImageContainer{position:relative}.visual-PBI_CV_Template .rcv_autoScaleImageContainer .rcv_autoScaleImage{max-width:100%;max-height:100%;position:absolute;top:50%;left:50%;transform:translateY(-50%) translateX(-50%);-webkit-transform:translateY(-50%) translateX(-50%)}","iconBase64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAIAAAAC64paAAAAb0lEQVQ4jWNkYGDonTiFgSzARJ42CGCBUMX5OSRpgziWGjYzMDD8J04DIxKbIpup5GxGVIn/OMSpZvNg0CzLww4nSdMsy8P++MtPBgYGCEmaZpL0oGsmDwyGFIYG8CQsFDVklyQMDAwMyiqq5GkEAMytEf/ahckCAAAAAElFTkSuQmCC"}}